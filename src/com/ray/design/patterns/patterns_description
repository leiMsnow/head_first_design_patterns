---------------------------设计原则---------------------------

1、开闭原则（Open Close Principle）
2、里氏代换原则（Liskov Substitution Principle）
3、依赖倒转原则（Dependence Inversion Principle）
4、接口隔离原则（Interface Segregation Principle）
5、迪米特法则（最少知道原则）（Demeter Principle）
6、合成复用原则（Composite Reuse Principle）


封装变化 - 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。
多用组合，少用继承。
为了交互对象之间的松耦合设计而努力。
找出程序中变化的方面，然后将其和固定不变的方面相分离。
针对接口编程，不针对实现编程。
类应该对扩展开放，对修改关闭。
依赖倒置 - 要依赖抽象，不要依赖具体类。
最少知识原则 - 只和你的密友谈话。
好莱坞原则 - 别调用我们，我们会调用你。

---------------------------设计模式---------------------------

创建型模式：

factory工厂方法模式 - 定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。

abstractFactory抽象工厂模式 - 提供一个接口，用户创建相关或依赖对象的家族，而不需要明确指定具体类。

singleton单例模式 - 确保一个类只有一个实例，并提供一个全局访问点。

结构型模式：

decorator装饰者模式 - 动态地将责任附加到对象上。想要扩展功能，装饰者提供有别与继承的另一种选择。

adapter适配器模式 - 将一个类的接口，转换成客户端期望的另一个接口，适配器让原本接口不兼容的类可以合作无间。

facade外观模式 - 提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。

行为型模式：

strategy策略模式 - 定义了算法族, 分别封装起来,让他们之间可以互相替换,此模式让算法的变化独立于使用算法的客户。

observer观察者模式 - 在对象之间定义一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象都会收到通知，并做出相应改变。

command命令模式 - 将“请求”封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象，命令模式也支持可撤销的操作。

template模板方法模式 -在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。
